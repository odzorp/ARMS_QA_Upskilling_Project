"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.uint8ArrayToBase64 = exports.toReversed = exports.shouldCommandBeSkipped = exports.resolveStatusWithDetails = exports.markTestAsReported = exports.last = exports.isTestReported = exports.isGlobalHook = exports.getSuitePath = exports.getNamesAndLabels = exports.getHookType = exports.applyTestPlan = void 0;
var _allureJsCommons = require("allure-js-commons");
var _sdk = require("allure-js-commons/sdk");
var _model = require("./model.js");
var _state = require("./state.js");
var uint8ArrayToBase64 = data => {
  // @ts-ignore
  var u8arrayLike = Array.isArray(data) || data.buffer;
  if (!u8arrayLike) {
    return data;
  }

  // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
  return btoa(String.fromCharCode.apply(null, data));
};
exports.uint8ArrayToBase64 = uint8ArrayToBase64;
var getSuitePath = test => {
  var path = [];
  var currentSuite = test.parent;
  while (currentSuite) {
    if (currentSuite.title) {
      path.unshift(currentSuite.title);
    }
    currentSuite = currentSuite.parent;
  }
  return path;
};
exports.getSuitePath = getSuitePath;
var shouldCommandBeSkipped = command => {
  var _last;
  if (((_last = last(command.attributes.args)) === null || _last === void 0 ? void 0 : _last.log) === false) {
    return true;
  }
  if (command.attributes.name === "task" && command.attributes.args[0] === "reportAllureRuntimeMessages") {
    return true;
  }

  // we don't need to report then commands because it's just a promise handle
  if (command.attributes.name === "then") {
    return true;
  }

  // we should skip artificial wrap from allure steps
  if (command.attributes.name === "wrap" && command.attributes.args[0] === _model.ALLURE_REPORT_STEP_COMMAND) {
    return true;
  }
  return false;
};
exports.shouldCommandBeSkipped = shouldCommandBeSkipped;
var toReversed = arr => {
  var result = [];
  for (var i = arr.length - 1; i >= 0; i--) {
    result.push(arr[i]);
  }
  return result;
};
exports.toReversed = toReversed;
var isGlobalHook = hookName => {
  return /(before|after) all/.test(hookName);
};
exports.isGlobalHook = isGlobalHook;
var last = arr => {
  return arr[arr.length - 1];
};
exports.last = last;
var getNamesAndLabels = (spec, test) => {
  var rawName = test.title;
  var {
    cleanTitle: name,
    labels
  } = (0, _sdk.extractMetadataFromString)(rawName);
  var suites = test.titlePath().slice(0, -1);
  var fullName = "".concat(spec.relative, "#").concat([...suites, name].join(" "));
  return {
    name,
    labels,
    fullName
  };
};
exports.getNamesAndLabels = getNamesAndLabels;
var applyTestPlan = (spec, root) => {
  var testPlan = (0, _state.getAllureTestPlan)();
  if (testPlan) {
    var suiteQueue = [];
    for (var s = root; s; s = suiteQueue.shift()) {
      var indicesToRemove = getIndicesOfDeselectedTests(testPlan, spec, s.tests);
      removeSortedIndices(s.tests, indicesToRemove);
      suiteQueue.push(...s.suites);
    }
  }
};
exports.applyTestPlan = applyTestPlan;
var resolveStatusWithDetails = error => error ? {
  status: (0, _sdk.getStatusFromError)(error),
  statusDetails: (0, _sdk.getMessageAndTraceFromError)(error)
} : {
  status: _allureJsCommons.Status.PASSED
};
exports.resolveStatusWithDetails = resolveStatusWithDetails;
var testReportedKey = Symbol("The test was reported to Allure");
var markTestAsReported = test => {
  test[testReportedKey] = true;
};
exports.markTestAsReported = markTestAsReported;
var isTestReported = test => test[testReportedKey] === true;
exports.isTestReported = isTestReported;
var hookTypeRegexp = /^"(before|after) (all|each)"/;
var getHookType = name => {
  var match = hookTypeRegexp.exec(name);
  if (match) {
    return [match[1], match[2]];
  }
  return [];
};
exports.getHookType = getHookType;
var includedInTestPlan = (testPlan, fullName, allureId) => testPlan.tests.some(test => {
  var _test$id;
  return allureId && ((_test$id = test.id) === null || _test$id === void 0 ? void 0 : _test$id.toString()) === allureId || test.selector === fullName;
});
var getIndicesOfDeselectedTests = (testPlan, spec, tests) => {
  var indicesToRemove = [];
  tests.forEach((test, index) => {
    var _labels$find;
    var {
      fullName,
      labels
    } = getNamesAndLabels(spec, test);
    var allureId = (_labels$find = labels.find(_ref => {
      var {
        name
      } = _ref;
      return name === _allureJsCommons.LabelName.ALLURE_ID;
    })) === null || _labels$find === void 0 ? void 0 : _labels$find.value;
    if (!includedInTestPlan(testPlan, fullName, allureId)) {
      indicesToRemove.push(index);
    }
  });
  return indicesToRemove;
};
var removeSortedIndices = (arr, indices) => {
  for (var i = indices.length - 1; i >= 0; i--) {
    arr.splice(indices[i], 1);
  }
};
//# sourceMappingURL=utils.js.map