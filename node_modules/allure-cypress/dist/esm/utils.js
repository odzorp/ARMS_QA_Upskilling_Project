import { LabelName, Status } from "allure-js-commons";
import { extractMetadataFromString, getMessageAndTraceFromError, getStatusFromError } from "allure-js-commons/sdk";
import { ALLURE_REPORT_STEP_COMMAND } from "./model.js";
import { getAllureTestPlan } from "./state.js";
export var uint8ArrayToBase64 = data => {
  // @ts-ignore
  var u8arrayLike = Array.isArray(data) || data.buffer;
  if (!u8arrayLike) {
    return data;
  }

  // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
  return btoa(String.fromCharCode.apply(null, data));
};
export var getSuitePath = test => {
  var path = [];
  var currentSuite = test.parent;
  while (currentSuite) {
    if (currentSuite.title) {
      path.unshift(currentSuite.title);
    }
    currentSuite = currentSuite.parent;
  }
  return path;
};
export var shouldCommandBeSkipped = command => {
  var _last;
  if (((_last = last(command.attributes.args)) === null || _last === void 0 ? void 0 : _last.log) === false) {
    return true;
  }
  if (command.attributes.name === "task" && command.attributes.args[0] === "reportAllureRuntimeMessages") {
    return true;
  }

  // we don't need to report then commands because it's just a promise handle
  if (command.attributes.name === "then") {
    return true;
  }

  // we should skip artificial wrap from allure steps
  if (command.attributes.name === "wrap" && command.attributes.args[0] === ALLURE_REPORT_STEP_COMMAND) {
    return true;
  }
  return false;
};
export var toReversed = arr => {
  var result = [];
  for (var i = arr.length - 1; i >= 0; i--) {
    result.push(arr[i]);
  }
  return result;
};
export var isGlobalHook = hookName => {
  return /(before|after) all/.test(hookName);
};
export var last = arr => {
  return arr[arr.length - 1];
};
export var getNamesAndLabels = (spec, test) => {
  var rawName = test.title;
  var {
    cleanTitle: name,
    labels
  } = extractMetadataFromString(rawName);
  var suites = test.titlePath().slice(0, -1);
  var fullName = "".concat(spec.relative, "#").concat([...suites, name].join(" "));
  return {
    name,
    labels,
    fullName
  };
};
export var applyTestPlan = (spec, root) => {
  var testPlan = getAllureTestPlan();
  if (testPlan) {
    var suiteQueue = [];
    for (var s = root; s; s = suiteQueue.shift()) {
      var indicesToRemove = getIndicesOfDeselectedTests(testPlan, spec, s.tests);
      removeSortedIndices(s.tests, indicesToRemove);
      suiteQueue.push(...s.suites);
    }
  }
};
export var resolveStatusWithDetails = error => error ? {
  status: getStatusFromError(error),
  statusDetails: getMessageAndTraceFromError(error)
} : {
  status: Status.PASSED
};
var testReportedKey = Symbol("The test was reported to Allure");
export var markTestAsReported = test => {
  test[testReportedKey] = true;
};
export var isTestReported = test => test[testReportedKey] === true;
var hookTypeRegexp = /^"(before|after) (all|each)"/;
export var getHookType = name => {
  var match = hookTypeRegexp.exec(name);
  if (match) {
    return [match[1], match[2]];
  }
  return [];
};
var includedInTestPlan = (testPlan, fullName, allureId) => testPlan.tests.some(test => {
  var _test$id;
  return allureId && ((_test$id = test.id) === null || _test$id === void 0 ? void 0 : _test$id.toString()) === allureId || test.selector === fullName;
});
var getIndicesOfDeselectedTests = (testPlan, spec, tests) => {
  var indicesToRemove = [];
  tests.forEach((test, index) => {
    var _labels$find;
    var {
      fullName,
      labels
    } = getNamesAndLabels(spec, test);
    var allureId = (_labels$find = labels.find(_ref => {
      var {
        name
      } = _ref;
      return name === LabelName.ALLURE_ID;
    })) === null || _labels$find === void 0 ? void 0 : _labels$find.value;
    if (!includedInTestPlan(testPlan, fullName, allureId)) {
      indicesToRemove.push(index);
    }
  });
  return indicesToRemove;
};
var removeSortedIndices = (arr, indices) => {
  for (var i = indices.length - 1; i >= 0; i--) {
    arr.splice(indices[i], 1);
  }
};
//# sourceMappingURL=utils.js.map